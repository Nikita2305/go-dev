# Сети

## TCP - детали имплементации протокола.

1. `go run main.go`

2.  `ifconfig` / `ip addr` - список интерфейсов

Находим лупбек - для резолва локалхоста, в моём случае lo0

3. `tcpdump -i lo0 -n -w file.pcap 'port 8080'`

Выбрали интерфейс который слушать, сказали не резолвить ip в хосты, сказали записать в файл, поставили кастомный фильтр в конце

4. `curl -v http://localhost:8080`

5. Выполнен http запрос, смотрим в wireshark, смотрим на то как всё работало:

```
1	0.000000	::1	::1	TCP	88	64272 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16324 WS=64 TSval=3938139019 TSecr=0 SACK_PERM
2	0.000069	::1	::1	TCP	88	8080 → 64272 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16324 WS=64 TSval=2285320863 TSecr=3938139019 SACK_PERM
3	0.000086	::1	::1	TCP	76	64272 → 8080 [ACK] Seq=1 Ack=1 Win=407744 Len=0 TSval=3938139019 TSecr=2285320863
4	0.000096	::1	::1	TCP	76	[TCP Window Update] 8080 → 64272 [ACK] Seq=1 Ack=1 Win=407744 Len=0 TSval=2285320863 TSecr=3938139019
5	0.000170	::1	::1	HTTP	153	GET / HTTP/1.1 
6	0.000182	::1	::1	TCP	76	8080 → 64272 [ACK] Seq=1 Ack=78 Win=407680 Len=0 TSval=2285320863 TSecr=3938139019
7	0.000411	::1	::1	HTTP	208	HTTP/1.1 200 OK  (text/plain)
8	0.000422	::1	::1	TCP	76	64272 → 8080 [ACK] Seq=78 Ack=133 Win=407616 Len=0 TSval=3938139019 TSecr=2285320863
9	0.000511	::1	::1	TCP	76	64272 → 8080 [FIN, ACK] Seq=78 Ack=133 Win=407616 Len=0 TSval=3938139019 TSecr=2285320863
10	0.000525	::1	::1	TCP	76	8080 → 64272 [ACK] Seq=133 Ack=79 Win=407680 Len=0 TSval=2285320863 TSecr=3938139019
11	0.000538	::1	::1	TCP	76	8080 → 64272 [FIN, ACK] Seq=133 Ack=79 Win=407680 Len=0 TSval=2285320863 TSecr=3938139019
12	0.000554	::1	::1	TCP	76	64272 → 8080 [ACK] Seq=79 Ack=134 Win=407616 Len=0 TSval=3938139019 TSecr=2285320863
```

В первых строках выполняется 3-way tcp handshake

Можно видеть размер пакетов от 88 до 76. Почему? 

Ведь мы ожидали 20 байт на ipv4 headers, 20 байт на tcp headers.

Во первых в wireshark можем видеть options занимают 24 и 12 байт соотв-но. Но тогда мы должны были получать 64 и 52 байта, а не 88 и 76.

Дело в том что по умолчанию был выбран Ipv6, из-за чего размер IP заголовка вырос до 40. Получается 84 и 72.

И ещё в рамках работы по loopback интерфейсу была зачем-то передана версия ip протокола (4 байта на ушли на целое число), поэтому и 88 и 76 байт было изначально соотв-но.

Давайте к более каноничному примеру вернёмся.

6. Используем Ipv4: `curl -4 http://localhost:8080`

```
1	0.000000	127.0.0.1	127.0.0.1	TCP	68	50127 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=1133359483 TSecr=0 SACK_PERM
2	0.000175	127.0.0.1	127.0.0.1	TCP	68	8080 → 50127 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=2602170592 TSecr=1133359483 SACK_PERM
3	0.000221	127.0.0.1	127.0.0.1	TCP	56	50127 → 8080 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=1133359483 TSecr=2602170592
```

Разберём подробно tcp handshake. Мы получили ожидаемые 68 байт: 20 (ip-headers) + 20 (tcp-headers) + 24 (tcp-options) + 4 (loopback overhead)

Давайте погрузимся в детали этих данных. Почему эти опции нужны, почему в последнем ACK запросе от клиента опции занимают 12 вместо 24 байт.

- если кратко: в процессе SYN - клиент и сервер обмениваются конфигурациями друг друга:
- MSS - maximum segment size. Это помогает клиенту понять, как много сервер готов принять без фрагментирования (на канальном уровне вроде)
- SACK - enabled-or-not. В этом месте мы обмениваемся информацией на тему того, доступен ли SELECTIVE ACKNOWLEDGE
- Timestamps - для синхронизации таймстепов клиента и сервера (как-то так)
- Window-Scale: x. После handshake recv-окно будет считаться по формуле window * 2^x.

Каждая опция кушает ещё пару байтов на Length/Option-Type. И дополнительно байты кушаются на выравнивание по 4 байтам. В моём случае между всеми опциями вставлялось по 1-2 NOP, каждый из которых есть по 1 байт (на Option-Type=1). В конце вставляется End-Of-Option List (Option-Type=0).

После SYN: SACK, MSS и Window Scale не посылаются, поддерживая только актуальность таймстемпов. Из-за чего последующие пакеты кушают по 12 байт.

```
4	0.000248	127.0.0.1	127.0.0.1	TCP	56	[TCP Window Update] 8080 → 50127 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=2602170592 TSecr=1133359483
```

Минуточку, а это что такое. А вот сервер прислал свой Window Scale. Дело в том, что это необходимо делать отдельным сегментом после хэндшейка, ибо в рамках хендшейка используется not-scaled window, что не посылай. В 3ем и 4ом запросах клиент и сервер обменялись актуальными window scales.


```
5	0.000266	127.0.0.1	127.0.0.1	HTTP	133	GET / HTTP/1.1 
6	0.000302	127.0.0.1	127.0.0.1	TCP	56	8080 → 50127 [ACK] Seq=1 Ack=78 Win=408192 Len=0 TSval=2602170592 TSecr=1133359483
```

Выше клиент отправил информацию а сервер её получил. SEQ и ACK номера описывают байты полезной нагрузки tcp. Видно что сервер отправил Ack по поводу 77 полученных байт.

```
7	0.000839	127.0.0.1	127.0.0.1	HTTP	188	HTTP/1.1 200 OK  (text/plain)
8	0.000871	127.0.0.1	127.0.0.1	TCP	56	50127 → 8080 [ACK] Seq=78 Ack=133 Win=408128 Len=0 TSval=1133359483 TSecr=2602170592
```

Выше сервер вернул информацию а клиент её получил.

```
9	0.000971	127.0.0.1	127.0.0.1	TCP	56	50127 → 8080 [FIN, ACK] Seq=78 Ack=133 Win=408128 Len=0 TSval=1133359484 TSecr=2602170592
10	0.001007	127.0.0.1	127.0.0.1	TCP	56	8080 → 50127 [ACK] Seq=133 Ack=79 Win=408192 Len=0 TSval=2602170593 TSecr=1133359484
11	0.001154	127.0.0.1	127.0.0.1	TCP	56	8080 → 50127 [FIN, ACK] Seq=133 Ack=79 Win=408192 Len=0 TSval=2602170593 TSecr=1133359484
12	0.001206	127.0.0.1	127.0.0.1	TCP	56	50127 → 8080 [ACK] Seq=79 Ack=134 Win=408128 Len=0 TSval=1133359484 TSecr=2602170593
```

Ну это просто финализация - сначала клиент шлёт серверу информацию о том, что он FINished посылать данные, сервер принимает это, затем ещё два запроса наоборот: 4-way disconnect. Это сделано в 4 похода а не в 3, потому что сервер не всегда может послать FIN вместе с ACK на FIN-запрос клиента: в том случае если он должен ещё дослать информацию клиенту, и только потом вжать FIN.

## TLS: ALPN и HTTP2.

1. `openssl req -x509 -newkey rsa:2048 -nodes -keyout key.pem -out cert.pem -days 365` - создаём самоподписанный сертификат

2. `go run main_2.go`

Поднимаем на 8443 порту приложение с проверкой сертификатов.

3. `sudo tcpdump -i lo0 -n 'port 8443' -w file.pcap`

4. `curl -v -4 -k https://localhost:8443`

`-k` - чтобы не проверять подпись сертификата

5. Смотрим wireshark:

```
1	0.000000	127.0.0.1	127.0.0.1	TCP	68	59019 → 8443 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=3061642275 TSecr=0 SACK_PERM
2	0.000102	127.0.0.1	127.0.0.1	TCP	68	8443 → 59019 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=2567795260 TSecr=3061642275 SACK_PERM
3	0.000130	127.0.0.1	127.0.0.1	TCP	56	59019 → 8443 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3061642275 TSecr=2567795260
4	0.000145	127.0.0.1	127.0.0.1	TCP	56	[TCP Window Update] 8443 → 59019 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=2567795260 TSecr=3061642275
```

Вещи, аналогичные http запросу. Потому что tcp протокол уровня ниже tls, и ему сначала надо установить соединение, только потом может пойти шифрование.

```
5	0.000413	127.0.0.1	127.0.0.1	TLSv1.3	375	Client Hello (SNI=localhost)
6	0.000439	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1 Ack=320 Win=407936 Len=0 TSval=2567795260 TSecr=3061642275
7	0.002804	127.0.0.1	127.0.0.1	TLSv1.3	1556	Server Hello, Change Cipher Spec, Application Data, Application Data, Application Data, Application Data
8	0.002834	127.0.0.1	127.0.0.1	TCP	56	59019 → 8443 [ACK] Seq=320 Ack=1501 Win=406784 Len=0 TSval=3061642278 TSecr=2567795263
9	0.031715	127.0.0.1	127.0.0.1	TLSv1.3	62	Change Cipher Spec
```

Примерно здесь закончился TLS handshake. Мы погрузимся в его детали чуть позже.

```
10	0.031738	127.0.0.1	127.0.0.1	TLSv1.3	114	Application Data
11	0.031767	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1501 Ack=326 Win=407936 Len=0 TSval=2567795292 TSecr=3061642307
12	0.031785	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1501 Ack=384 Win=407872 Len=0 TSval=2567795292 TSecr=3061642307
13	0.031840	127.0.0.1	127.0.0.1	TLSv1.3	142	Application Data
14	0.031861	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1501 Ack=470 Win=407808 Len=0 TSval=2567795292 TSecr=3061642307
15	0.031912	127.0.0.1	127.0.0.1	TLSv1.3	117	Application Data
16	0.031940	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1501 Ack=531 Win=407744 Len=0 TSval=2567795292 TSecr=3061642307
17	0.032031	127.0.0.1	127.0.0.1	TLSv1.3	117	Application Data
18	0.032051	127.0.0.1	127.0.0.1	TCP	56	59019 → 8443 [ACK] Seq=531 Ack=1562 Win=406720 Len=0 TSval=3061642307 TSecr=2567795292
19	0.032253	127.0.0.1	127.0.0.1	TLSv1.3	100	Application Data
20	0.032276	127.0.0.1	127.0.0.1	TCP	56	59019 → 8443 [ACK] Seq=531 Ack=1606 Win=406656 Len=0 TSval=3061642307 TSecr=2567795292
21	0.032310	127.0.0.1	127.0.0.1	TLSv1.3	87	Application Data
22	0.032327	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1606 Ack=562 Win=407680 Len=0 TSval=2567795292 TSecr=3061642307
23	0.032549	127.0.0.1	127.0.0.1	TLSv1.3	160	Application Data
24	0.032570	127.0.0.1	127.0.0.1	TCP	56	59019 → 8443 [ACK] Seq=562 Ack=1710 Win=406528 Len=0 TSval=3061642308 TSecr=2567795293
25	0.032737	127.0.0.1	127.0.0.1	TLSv1.3	80	Application Data
26	0.032756	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [ACK] Seq=1710 Ack=586 Win=407680 Len=0 TSval=2567795293 TSecr=3061642308
27	0.032794	127.0.0.1	127.0.0.1	TCP	56	59019 → 8443 [FIN, ACK] Seq=586 Ack=1710 Win=406528 Len=0 TSval=3061642308 TSecr=2567795293
28	0.032800	127.0.0.1	127.0.0.1	TLSv1.3	80	Application Data
29	0.032811	127.0.0.1	127.0.0.1	TCP	56	8443 → 59019 [FIN, ACK] Seq=1734 Ack=586 Win=407680 Len=0 TSval=2567795293 TSecr=3061642308
```

Стало интересно, почему тут значительно больше обмена сообщениями чем без TLS. Поразбиравшись, я увидел что curl использовал HTTP/2 - говорят это произошло через ALPN - application level protocol negotiation. В процессе Client Hello - мы послали возможные протоколы: http2 и http1.1. В процессе Server Hello - мы выбрали один из них. Могло ли из-за использования http2 стать больше пакетов? Если да, то почему? Поскольку HTTP/2 оперирует фреймами - HEADERS, WINDOW UPDATE, DATA - всё это приходит в отдельных фреймах (TCP сегментах), то действиетльно их должно было стать больше.

```
30	0.032823	127.0.0.1	127.0.0.1	TCP	56	[TCP Retransmission] 8443 → 59019 [FIN, ACK] Seq=1734 Ack=587 Win=407680 Len=0 TSval=2567795293 TSecr=3061642308
31	0.032862	127.0.0.1	127.0.0.1	TCP	44	59019 → 8443 [RST] Seq=586 Win=0 Len=0
32	0.032866	127.0.0.1	127.0.0.1	TCP	44	59019 → 8443 [RST] Seq=586 Win=0 Len=0
33	0.032867	127.0.0.1	127.0.0.1	TCP	44	59019 → 8443 [RST] Seq=587 Win=0 Len=0
```

Забавно, что в конце произошёл ретрансмит FIN соединения от серера. Клиент видимо не дождался ответа и перестал слушать сокет после отправки Fin. А потом клиент отправил RST в качестве сигнального "у меня что-то пошло не так, я разрываю соединение в одностороннем порядке". 

## TLS: к деталям

Исполним `curl --http1.1 -v -4 -k https://localhost:8443` - и увидим что пакетов стало меньше, как и ожидалось. Рассмотрим:

```
1	0.000000	127.0.0.1	127.0.0.1	TCP	68	53875 → 8443 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=3810664787 TSecr=0 SACK_PERM
2	0.000059	127.0.0.1	127.0.0.1	TCP	68	8443 → 53875 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=73587986 TSecr=3810664787 SACK_PERM
3	0.000072	127.0.0.1	127.0.0.1	TCP	56	53875 → 8443 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3810664787 TSecr=73587986
4	0.000083	127.0.0.1	127.0.0.1	TCP	56	[TCP Window Update] 8443 → 53875 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=73587986 TSecr=3810664787
```

Это мы обсуждали ранее. Перейдём к TLS. 

```
5	0.002822	127.0.0.1	127.0.0.1	TLSv1.3	372	Client Hello (SNI=localhost)
6	0.002846	127.0.0.1	127.0.0.1	TCP	56	8443 → 53875 [ACK] Seq=1 Ack=317 Win=407936 Len=0 TSval=73587988 TSecr=3810664789
7	0.012853	127.0.0.1	127.0.0.1	TLSv1.3	1562	Server Hello, Change Cipher Spec, Application Data, Application Data, Application Data, Application Data
8	0.012909	127.0.0.1	127.0.0.1	TCP	56	53875 → 8443 [ACK] Seq=317 Ack=1507 Win=406784 Len=0 TSval=3810664799 TSecr=73587998
9	0.045429	127.0.0.1	127.0.0.1	TLSv1.3	62	Change Cipher Spec
10	0.045440	127.0.0.1	127.0.0.1	TLSv1.3	114	Application Data
11	0.045459	127.0.0.1	127.0.0.1	TCP	56	8443 → 53875 [ACK] Seq=1507 Ack=323 Win=407936 Len=0 TSval=73588031 TSecr=3810664832
12	0.045472	127.0.0.1	127.0.0.1	TCP	56	8443 → 53875 [ACK] Seq=1507 Ack=381 Win=407872 Len=0 TSval=73588031 TSecr=3810664832
```

Произошёл tls handshake. Клиент и сервер обменялись key_share, затем собрали shared_secret из них и с помощью рандомных ключей в client/server hello собирают session_key.

Как можно видеть, в 7ом запросе видно, что есть много Application Data - это tls records которые доставляют до клиента Certificate и Finished сообщение, помогая клиенту удостовериться что мы пришли на тот sni, на который хотели. Касательно сертификата - это как раз cert.pem. Мы сначала возвращаем клиенту Certificate, а затем CertificateVerify: это подпись (зашифровка) всего предыдущего хэндшейка приватным ключом, которую клиент сможет проверить публичным ключом.

В 10ом запросе клиент всё проверил и послал Finished на сервер.

```
13	0.045592	127.0.0.1	127.0.0.1	TLSv1.3	155	Application Data
14	0.045613	127.0.0.1	127.0.0.1	TCP	56	8443 → 53875 [ACK] Seq=1507 Ack=480 Win=407808 Len=0 TSval=73588031 TSecr=3810664832
15	0.046809	127.0.0.1	127.0.0.1	TLSv1.3	210	Application Data
16	0.046826	127.0.0.1	127.0.0.1	TCP	56	53875 → 8443 [ACK] Seq=480 Ack=1661 Win=406592 Len=0 TSval=3810664833 TSecr=73588032
```

Сервер и клиент обменялись зашифрованной информацией. Интересно что всё-таки пакетов полезной нагрузки МОЖЕТ ходить больше - ведь TLS протокол может разбивать необходимый запрос на TLS-records. Хидеры могут пойти в одном заголовке - тело в другом. Вероятно curl ровно это и сделал. Это позволяет на стороне сервера быстрее начать расшифровывать то, что пришло (фрагментация).

```
17	0.046937	127.0.0.1	127.0.0.1	TLSv1.3	80	Application Data
18	0.046951	127.0.0.1	127.0.0.1	TCP	56	8443 → 53875 [ACK] Seq=1661 Ack=504 Win=407744 Len=0 TSval=73588032 TSecr=3810664833
19	0.046974	127.0.0.1	127.0.0.1	TLSv1.3	80	Application Data
```

Где-то в этот момент мы закончили TLS соединение (отправлся устаревший close_notify обеими сторонами).

```
20	0.046983	127.0.0.1	127.0.0.1	TCP	56	8443 → 53875 [FIN, ACK] Seq=1685 Ack=504 Win=407744 Len=0 TSval=73588032 TSecr=3810664833
21	0.046987	127.0.0.1	127.0.0.1	TCP	56	53875 → 8443 [ACK] Seq=504 Ack=1685 Win=406592 Len=0 TSval=3810664833 TSecr=73588032
22	0.046994	127.0.0.1	127.0.0.1	TCP	56	53875 → 8443 [ACK] Seq=504 Ack=1686 Win=406592 Len=0 TSval=3810664833 TSecr=73588032
23	0.047025	127.0.0.1	127.0.0.1	TCP	44	53875 → 8443 [RST, ACK] Seq=504 Ack=1686 Win=406592 Len=0
```

Ну собственно тут сервер сказал "до свидания", а клиент отрапортовал что дочитал данные и тоже закрыл соединение (но не gracefully).

## HTTP2

Мы от него как-то открестились, а это же база, это знать надо.  Без TLS, чтобы было нагляднее.

`curl -v -4 --http2 http://localhost:8080`

Однако это оказалось не так просто! Http2 без TLS это так скажем не база.

Чтобы оно зарабаотало, клиент сперва посылает upgrade запрос, а затем уже после ответа сервера `101 Switching Protocols` продолжает работу:

```
GET / HTTP/1.1
Host: localhost:8080
Upgrade: h2c
Connection: Upgrade, HTTP2-Settings
HTTP2-Settings: <base64>
```

Однако в нашем случае мы получили ответ: `curl: (55) Remote peer returned unexpected data while we expected SETTINGS frame.  Perhaps, peer does not support HTTP/2 properly.`. Значит go-сервер на поддержал http2 без tls (h2c) соответтсвующе (справедливости ради это необходимо только для отладки).

Поэтому появилась новая реализация: `go run main_3.go`

Сайд история №1:
- `go mod init github.com/Nikita2305/h2c` - инициализировал go mod
- `go mod tidy` - скачал и добавил зависимости

Сайд история №2: есть `curl -v --http2-prior-knowledge http://localhost:8080`. Оно работает без апгрейд запроса и сразу посылает http2 фреймы.

К делу, рассмотрим самое важное (отбросив установку и разрыв TCP соединения):

```
5	0.000270	127.0.0.1	127.0.0.1	HTTP	226	GET / HTTP/1.1 
6	0.000286	127.0.0.1	127.0.0.1	TCP	56	8080 → 57529 [ACK] Seq=1 Ack=171 Win=408128 Len=0 TSval=2434668680 TSecr=3634309639
7	0.001228	127.0.0.1	127.0.0.1	HTTP	127	HTTP/1.1 101 Switching Protocols 
8	0.001246	127.0.0.1	127.0.0.1	TCP	56	57529 → 8080 [ACK] Seq=171 Ack=72 Win=408192 Len=0 TSval=3634309641 TSecr=2434668682
```

Тот самый апгрейд запрос

```
9	0.001365	127.0.0.1	127.0.0.1	HTTP2	120	Magic, SETTINGS[0], WINDOW_UPDATE[0]
10	0.001385	127.0.0.1	127.0.0.1	TCP	56	8080 → 57529 [ACK] Seq=72 Ack=235 Win=408064 Len=0 TSval=2434668682 TSecr=3634309641
11	0.001509	127.0.0.1	127.0.0.1	HTTP2	95	SETTINGS[0]
12	0.001516	127.0.0.1	127.0.0.1	TCP	56	57529 → 8080 [ACK] Seq=235 Ack=111 Win=408128 Len=0 TSval=3634309641 TSecr=2434668682
13	0.001580	127.0.0.1	127.0.0.1	HTTP2	65	SETTINGS[0]
14	0.001599	127.0.0.1	127.0.0.1	TCP	56	8080 → 57529 [ACK] Seq=111 Ack=244 Win=408000 Len=0 TSval=2434668682 TSecr=3634309641
15	0.001662	127.0.0.1	127.0.0.1	HTTP2	69	WINDOW_UPDATE[0]
16	0.001679	127.0.0.1	127.0.0.1	TCP	56	57529 → 8080 [ACK] Seq=244 Ack=124 Win=408128 Len=0 TSval=3634309641 TSecr=2434668682
17	0.001754	127.0.0.1	127.0.0.1	HTTP2	65	SETTINGS[0]
18	0.001764	127.0.0.1	127.0.0.1	TCP	56	57529 → 8080 [ACK] Seq=244 Ack=133 Win=408128 Len=0 TSval=3634309641 TSecr=2434668682
19	0.001886	127.0.0.1	127.0.0.1	HTTP2	138	HEADERS[1]: 200 OK, DATA[1] (text/plain)
20	0.001901	127.0.0.1	127.0.0.1	TCP	56	57529 → 8080 [ACK] Seq=244 Ack=215 Win=408064 Len=0 TSval=3634309641 TSecr=2434668682
```

Основная идея http2 - мультиплексирование. Возможность отправлять несколько http запросов по tcp соединению одновременно (не ждать пока предыдущий запрос завершится - в браузеры для этого в http1.1 даже 6 коннектов засунули). Ну а чтобы управлять разными http запросами, нам нужно несколько буферов загрузки - поэтому добавили отдельные window update / settings и прочее с указанием stream_id [кусочек информации в http - это фрейм в рамках стрима: фреймы бывают data / headers / settings / window update]. В общем своего рода добавили структуру, вместо plain text http.

Дополнительно есть компрессия http header-ов в рамках одного tcp соединения. Если ты посылаешь много запросов через него, то скорее всего хедеры будут похожи - они закэшируются на клиенте и сервере и будут отправляться специальным "encoding".